'''
The provided code snippet is for solving ordinary differential equations (ODEs)
using two different numerical methods: 
    the Forward Euler method and the Runge-Kutta 4 method
The code has been rewritten using modern Python methods and libraries. 
The plots generated by the code have been displayed above, 
illustrating the solutions of the differential equation 
uâ€²=u using both the Forward Euler method (approximated with RK23) 
and the Runge-Kutta 4 method (RK45) at various time steps.

Here is a brief explanation of the changes:
NumPy is used for numerical operations, such as creating arrays of time points.
Matplotlib is used for plotting the numerical solutions and the exact solution.
SciPy's solve_ivp is used to solve the initial value problem with specified 
methods. RK23 is used to mimic the Forward Euler method, and RK45 is an 
implementation of the classical Runge-Kutta method of order 4.
The code now includes comments that explain each step and the use 
of context managers for creating figures.
We've plotted the exact solution for comparison with the numerical solutions. 
The exact solution is plotted as a dashed line for clarity.
The solve_ivp function is versatile and can be used with various built-in 
methods for solving ODEs. It also handles the time stepping internally, 
which simplifies the code.
'''

#Import Libraries
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# Define the differential equation f(u, t) = u
def f(t, u):
    return u

# Define the time span and the initial condition
T = 3
t_span = (0, T)
u0 = [1.0]

# Create a figure for the plots
plt.figure()

# Solve the ODE with a fine resolution for plotting the exact solution
t_exact = np.linspace(0, T, 400)
u_exact = np.exp(t_exact)
plt.plot(t_exact, u_exact, label='Exact Solution', linestyle='--')

# Solve the ODE using the Forward Euler method with different time steps
for dt in [0.1, 0.5, 1.0]:
    n = int(round(T/dt))
    t_eval = np.linspace(0, T, n+1)
    sol = solve_ivp(f, t_span, u0, method='RK23', t_eval=t_eval)
    plt.plot(sol.t, sol.y[0], label=f'Forward Euler, dt={dt}')

# Adding title, legend, and labels
plt.title("Solution of u'=u with Forward Euler method")
plt.xlabel('Time t')
plt.ylabel('Solution u')
plt.legend()
plt.show()

# Now for a comparison between Forward Euler and Runge-Kutta 4 (RK45 in solve_ivp)
dt = 1.0
n = int(round(T/dt))
t_eval = np.linspace(0, T, n+1)

# Create a new figure for the comparison
plt.figure()

# Solve the ODE using both Forward Euler and RK45
methods = ('RK23', 'Forward Euler','RK45', 'Runge-Kutta 4')
for method, name in methods:
    sol = solve_ivp(f, t_span, u0, method=method, t_eval=t_eval)
    plt.plot(sol.t, sol.y[0], label=name)

# Plot the exact solution
plt.plot(t_exact, u_exact, label='Exact Solution', linestyle='--')

# Adding title, legend, and labels
plt.title("Comparison of Numerical Methods for u'=u")
plt.xlabel('Time t')
plt.ylabel('Solution u')
plt.legend()
plt.show()